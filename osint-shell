#!/usr/bin/env python
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4

import cmd
import urllib2
import urlparse
import re
import lxml
from lxml import etree
import json
import string
import requests
from bs4 import BeautifulSoup

class Module(object):
    @classmethod
    def complete_methods(cls, text):
        if not text:
            return cls.available_methods()[:]
        else:
            return [n for n in cls.available_methods()
                            if n.upper().startswith(text.upper())]

    @classmethod
    def available_methods(cls):
        return [fn[3:] for fn in dir(cls) if fn.startswith('do_')]

    @classmethod
    def parse_cmd(cls, line):
        return line.split()

    def __init__(self, shell):
        self.shell = shell

    def execute_method(self, method_name, args):
        return getattr(self, 'do_%s' % method_name)(args)


class HTTPResponse(object):
    XPATH_QUERY_ENCODING = "/html/head/meta[@http-equiv='Content-Type']/@content|/html/head/meta[@http-equiv='Content-type']/@content|/html/head/meta[@http-equiv='content-type']/@content"
    DEFAULT_RESPONSE_ENCODAGE = 'UTF-8'

    XPATH_QUERY_PAGE_TITLE = "//title/text()"
    XPATH_QUERY_RSS_FEEDS = "//link[@type='application/rss+xml']/@href"
    XPATH_QUERY_TITLES = "//h{i}/*/text()|//h{i}/text()"
    XPATH_QUERY_ANCHORS = "//a/@href"

    def __init__(self, url):
        self.raw_resp = urllib2.urlopen(url)
        self.code = self.raw_resp.getcode()
        self.url = self.raw_resp.geturl()
        self.body = self.raw_resp.read()
        self.headers = self.raw_resp.info()
        self.soup = BeautifulSoup(self.body)
        self.parsed_data = etree.fromstring(self.body,
                                    etree.HTMLParser(encoding=self.encoding))

    @property
    def anchors(self):
        anchors = [urlparse.urljoin(self.url, href)
                        for href in self.parsed_data.xpath(
                                self.XPATH_QUERY_ANCHORS)]
        return sorted(set(anchors))

    @property
    def page_title(self):
        return self.parsed_data.xpath(self.XPATH_QUERY_PAGE_TITLE)[0]

    @property
    def rss_feeds(self):
        return self.parsed_data.xpath(self.XPATH_QUERY_RSS_FEEDS)

    @property
    def encoding(self):
        try:
            for header in self.headers:
                if header.lower() == 'content-type':
                    return re.search(r"charset=(.*)",
                                self.headers[header]).group(1)
        except:
            # print "Cannot detect encoding in HTTP Headers. Test in HTML document."
            pass

        try:
            parsed_data = etree.fromstring(self.body, etree.HTMLParser())
            return re.search(r"charset=(.*)", parsed_data.xpath(
                        self.XPATH_QUERY_ENCODING)[0]).group(1)
        except:
            # print "Cannot detect encoding in HTML document."
            # print "Fixed at '%s'." % self.DEFAULT_RESPONSE_ENCODAGE
            pass
        return self.DEFAULT_RESPONSE_ENCODAGE

    @property
    def titles(self):
        titles = []
        for i in range(0, 6):
            for txt in self.parsed_data.xpath(self.XPATH_QUERY_TITLES.format(i=i)):
                titles.append({'tag': 'H{i}'.format(i=i),
                               'content': txt.strip()})
        return titles

    def xpath_query(self, query):
        return self.parsed_data.xpath(query)

    def css_select(self, query):
        return self.soup.select(query)

    def __str__(self):
        return urlparse.urlparse(self.url).hostname


class HTTPModule(Module):

    def do_request_get(self, args):
        self.current_response = HTTPResponse(' '.join(args))
        self.shell.print_line(self.current_response.code)

    def do_response_headers(self, args):
        for header in self.current_response.headers:
            self.shell.print_line(
                    '{k}: {v}'.format(k=string.ljust(header, 25),
                                      v=self.current_response.headers[header]))

    def do_response_url(self, args):
        self.shell.print_line(self.current_response.url)

    def do_response_body(self, args):
        self.shell.print_raw(self.current_response.body)

    def do_response_status_code(self, args):
        self.shell.print_line(self.current_response.code)

    def do_response_encoding(self, args):
        self.shell.print_line(self.current_response.encoding)

    def do_response_extract_page_title(self, args):
        self.shell.print_line(self.current_response.page_title)

    def do_response_extract_rss_feeds(self, args):
        for url in self.current_response.rss_feeds:
            self.shell.print_line(url)

    def do_response_extract_anchors(self, args):
        for url in self.current_response.anchors:
            self.shell.print_line(url)

    def do_response_extract_titles(self, args):
        for t in self.current_response.titles:
            if len(t['content']) > 0:
                self.shell.print_line('%s: %s' % (t['tag'], t['content']))

    def do_response_extract_hosts(self, args):
        hosts = ['http://{0}'.format(urlparse.urlparse(url).hostname)
                        for url in self.current_response.anchors]
        for host in sorted(set(hosts)):
            self.shell.print_line(host)

    def do_response_xpath_query(self, args):
        for element in self.current_response.xpath_query(' '.join(args)):
            self.shell.print_line(element)

    def do_response_css_select(self, args):
        for element in self.current_response.css_select(' '.join(args)):
            self.shell.print_line(element)

    def do_clear_response(self, args):
        try:
            del(self.current_response)
        except:
            pass

    def __str__(self):
        try:
            return 'mod-http: {data}'.format(data=str(self.current_response))
        except:
            return 'mod-http: <no-data>'

class GoogleModule(Module):
    GOOGLE_SEARCH_URL = 'http://www.google.com/search'
    # http://clients1.google.com/complete/search?hl=en&output=toolbar&q=YOURSEARCHTERM
    # http://suggestqueries.google.com/complete/search?output=toolbar&hl=en&q=YOURSEARCHTERM
    GOOGLE_SUGGEST_URL = 'http://suggestqueries.google.com/complete/search' # output=toolbar&hl=en&q=YOURSEARCHTERM

    def __str__(self):
        return 'mod-google'

    def do_suggest(self, args):
        query = ' '.join(args)
        self.shell.print_line('suggest: %s' % query)
        html = requests.get(self.GOOGLE_SUGGEST_URL, params={
                            'q': query, 'output': 'toolbar', 'hl': 'fr'}).content
        soup = BeautifulSoup(html)
        for s in soup.find_all('suggestion'):
            self.shell.print_line(s.get('data', ''))

    def do_search(self, args):
        query = ' '.join(args)
        url_list = []
        self.shell.print_line('search: %s' % query)

        for i in (0, 10, 20):
            print 'Retreive results for page: %s' % i
            html = requests.get(self.GOOGLE_SEARCH_URL, params={
                       'q': query,'oq': query, 'hl': 'fr', 'start': i}).content
            soup = BeautifulSoup(html)
            for a in soup.find_all('a'):
                href = a.get('href', '/')
                url = urlparse.urljoin(self.GOOGLE_SEARCH_URL, href)
                parsed_url = urlparse.urlparse(url)
                parsed_query = urlparse.parse_qs(parsed_url.query)
                if parsed_url.path == '/url':
                    founded_url = parsed_query['q'][0]
                    parsed_url = urlparse.urlparse(founded_url)
                    if parsed_url.hostname != 'webcache.googleusercontent.com':
                        url_list.append(founded_url)

        for url in set(url_list):
            self.shell.print_line(url)


class OSINTShell(cmd.Cmd):
    # prompt = 'osint-shell (<no data>)$ '
    ruler = '-'
    # modules = [
    #         {'cmd': 'http', 'cls': 'HTTPModule', 'instance': None}
    # ]

    # modules must be implement methods:
    #       - do_<module name> and complete_<module name>
    AVAILABLE_MODULES = {
            'http': 'HTTPModule'
    }

    def do_modules(self, line):
        'list available modules'
        for cmd, cls in self.AVAILABLE_MODULES.iteritems():
            self.print_line('{}: {}'.format(cmd, cls))
        # for mod_data in self.modules:
        #     status = 'not loaded' if mod_data['instance'] == None else 'loaded'
        #     self.print_line('{cmd} ({cls}): {status}'.format(
        #                 cmd=mod_data['cmd'],
        #                 cls=mod_data['cls'],
        #                 status=status))

    # def default(self, line):
        # print 'default: %s' % line
        # args = Module.parse_cmd(line)
        # for mod_data in self.modules:
        #     if args[0] == mod_data['cmd']:
        #         mod_data['instance'] = globals()[mod_data['cls']](self)

    def do_google(self, line):
        'Google manipulation. Use search and suggest services'
        try:
            args = GoogleModule.parse_cmd(line)
            self.current_module = GoogleModule(self)
            self.current_module.execute_method(args[0], args[1:])
        except Exception as e:
            self.print_line(e)

    def complete_google(self, text, line, begidx, endidx):
        return GoogleModule.complete_methods(text)


    def do_http(self, line):
        'HTTP manipulation. Use: http request_get http://www.google.com'
        try:
            args = HTTPModule.parse_cmd(line)
            if self.current_module == None\
                    or not isinstance(self.current_module, HTTPModule):
                self.current_module = HTTPModule(self)

            self.current_module.execute_method(args[0], args[1:])

        except Exception as e:
            print e

    def complete_http(self, text, line, begidx, endidx):
        return HTTPModule.complete_methods(text)

    def normalize_prompt(self):
        str = 'no module loaded' \
                    if self.current_module == None else self.current_module
        self.prompt = 'osint-shell (%s)$ ' % str

    def print_line(self, line):
        print ' [+] %s' % line

    def print_raw(self, raw_text):
        print raw_text

    def postcmd(self, stop, line):
        self.normalize_prompt()
        return cmd.Cmd.postcmd(self, stop, line)

    def preloop(self):
        self.normalize_prompt()

    def do_quit(self, line):
        'Quit OSINT Shell'
        print 'Quitting...'
        return True

    def cmdloop(self, intro=''):
        try:
            self.current_module = None
            cmd.Cmd.cmdloop(self, intro=intro)
        except KeyboardInterrupt as e:
            print '^C'
            self.cmdloop()

INTRO = """
         _/_/_/     _/_/_/_/  _/_/_/  _/    _/  _/_/_/_/
      _/       _/  _/          _/    _/_/  _/    _/
     _/       _/  _/_/_/_/    _/    _/ _/ _/    _/
    _/       _/        _/    _/    _/  _/_/    _/
      _/_/_/    _/_/_/_/  _/_/_/  _/    _/    _/

             THE OSINT INVESTIGATION TOOL
"""

if __name__ == '__main__':
    OSINTShell().cmdloop(INTRO)

